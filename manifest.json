{
  "id": "Hianime",
  "name": "Hianime",
  "description": "GojoWtf is an online streaming provider for subbed and dubbed anime in English. It supports two providers: Strix and Pahe, both of which offer subbed and dubbed content",
  "manifestURI": "https://github.com/Brokenest/hianime/edit/main/manifest.json#L3C18",
  "version": "1.0.2",
  "author": "kRYstall9",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "en",
  "payload": "/// <reference path=\"./onlinestream-provider.d.ts\" />\n/// <reference path=\"./core.d.ts\" />\n\nclass Provider {\n\n    // Updated API and Base URL for hianimeZ.is\n    api: string = 'https://api.hianimez.is'; // Replace with the actual API endpoint\n    baseUrl: string = 'https://hianimez.is';\n    threshold: number = 0.7;\n    headers = {\n        'Referer': 'https://hianimez.is/',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'\n    };\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"server1\", \"server2\"], // Update with actual server names used by hianimeZ.is\n            supportsDub: true,\n        };\n    }\n\n    async search(query: SearchOptions): Promise<SearchResult[]> {\n        const normalizedQuery = normalizeQuery(query.query);\n        console.debug(normalizedQuery);\n\n        const language: string = query.dub ? \"dub\" : \"sub\";\n        let url = `${this.api}/search?query=${encodeURIComponent(normalizedQuery)}&page=1&year=${query.year != null ? query.year : 'any'}`;\n\n        try {\n            let response = await _makeRequest(url, this.headers);\n            let data = JSON.parse(response);\n            const pages = data.lastPage;\n\n            const aniListTitlesAndSynonyms = [query.media.englishTitle ?? \"\", query.media.romajiTitle ?? \"\", ...query.media.synonyms];\n            const validTitles = new Map<string, LevenshteinResult>();\n            const results: SearchResult[] = [];\n            let shouldContinue: boolean = true;\n\n            for (let i = 1; i <= pages; i++) {\n                if (i > 1) {\n                    url = `${url.split(\"&page\")[0]}&page=${i}`;\n                    try {\n                        response = await _makeRequest(url, this.headers);\n                    }\n                    catch (error: any) {\n                        console.error(error);\n                    }\n                }\n\n                for (let anime of data.results) {\n                    let japaneseTitle = anime.title.romaji;\n                    let title = anime.title.english;\n                    let nativeTitle = anime.title.native;\n                    let id = anime.id;\n                    let url = `${this.baseUrl}/anime/${id}`;\n                    let subOrDub: SubOrDub = query.dub ? \"dub\" : \"sub\";\n                    const titles = [japaneseTitle, title, nativeTitle];\n\n                    try {\n                        for (let t of titles) {\n\n                            let bestScore: number | null = filterBySimilarity(t, aniListTitlesAndSynonyms, this.threshold);\n                            if (bestScore != null) {\n                                validTitles.set(title, { score: bestScore, subOrDub: subOrDub, title: title });\n                                if (bestScore == 1) {\n                                    shouldContinue = false;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    catch (error) {\n                        console.error(\"Error: \" + error);\n                    }\n\n                    results.push({\n                        id: `${id}/${subOrDub}`,\n                        title: title,\n                        url: url,\n                        subOrDub: subOrDub,\n                    });\n\n                    if (!shouldContinue)\n                        break;\n                }\n                if (!shouldContinue)\n                    break;\n            }\n\n            console.debug(validTitles);\n            if (validTitles.size > 0) {\n                let bestMatch = Array.from(validTitles.values()).reduce((prev, current) =>\n                    prev.score > current.score ? prev : current\n                );\n\n                console.log(\"Best Match \", bestMatch);\n\n                let animeToReturn = results\n                    .filter((anime: any) => anime.subOrDub === (query.dub ? \"dub\" : \"sub\"))\n                    .filter((anime: any) => anime.title.toLowerCase() === bestMatch.title.toLowerCase())[0];\n\n                if (animeToReturn) {\n                    return [animeToReturn];\n                }\n            }\n        } catch (error) {\n            console.error(error);\n        }\n\n        return [];\n    }\n}\n"
}
